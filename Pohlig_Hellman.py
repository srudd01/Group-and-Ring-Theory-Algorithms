from math import ceil, floor, sqrt, gcd
from numpy import prod


def m_inverse(x, n):
  #Calculates the multiplicative inverse of an element of the ring of integers modulo n, n>=2. Explicitly requires x is therefore coprime to n as these are the only invertible elements of the ring.
  #Here we are implicitly using the Extended Euclidean Algorithm.
  n0 = n
  x0, x1 = 0, 1
  while x > 1:
    s = x // n0
    x,n0 = n0, x%n0
    x0, x1 = x1-s*x0, x0
  if x1 < 0:
    x1 += n
  return x1
    
  

def chineseRemainderTheorem(a, mod):
  #Takes in two lists, one pertaining to the equivalence classes, a, and one pertaining to the moduluses, mod. These lists will later by zipped in order to create a list of tuples e.g. for 3 mod 5, 6 mod 9 we would have [(3,5), (6,9)]
  #We explicitly require by the Chinese Remainder Theorem that all moduli are coprime.
  #Multiply all moduli together for new modulus.
  total = 0
  N = prod(mod)
  for i,j in zip(a,mod):
    t = N / j
    total += i * m_inverse(t, j) * t
  
  return total % N

def additiveSubgroup (n, g):
  #We consider the additive group of integers modulo n given by Z_n^+ and an element of this group given by g.
  #Notice that g is a generator for n if and only if g is coprime to n.
  c = gcd(n,g)
  if c == 1:
    return list(range(1,n+1))
  else:
    lst = []
    #Since g is not a generator here at the very most it has order of the floor of n/2. Without solving the hard problem of factorisation we cannot assume more than this without information about the factors of n.
  for i in range(floor(n/2)+1):
    k = int(g*i % n)
    if k not in lst:
      lst.append(int(g*i % n))
  return lst

def babyStepGiantStep(n, m, g, x):
  #Given the cyclic group Z_n^+ and a subgroup generated by g of order m find r such that g**r = x.
  #This modulo assignment makes sure that x is of the correct form for the algorithm.
  x = x % n
  d = {}
  h = ceil(sqrt(m))
  for i in range(h):
    d.update({i: g*i % n})
  y = x
  for i in range(h):
    for j in range(h):
      if d[j] == y:
        return int(i*h + j)
    else:
      y = (y + g*(-h)) % n

def primePowerHellman(p, e, g, x):
  #Runs a special case of the Pohlig-Hellman algorithm where the order of the additive group of integers modulo p**e (Z_n^+), p**e = n is a prime power.
  #p denotes the prime, e denotes the exponent, g denotes a generator for the cyclic group Z_n^+, x is an arbitrary element of Z_n^+
  #We will calculate r_i via h_i and d_i and initialise these here. We will eventually have that g**r_{n-1} = x as required.
  r = [0]
  h = []
  d = []
  n = p**e
  #Compute y, noticing y has order p via Lagrange's Theorem - the entire group has order p**e, y**p = g**(p**e) = 0 mod p**e, the identity element. This is the least value that this happens at since g is a generator for Z_n^+.
  y = int(g*(p**(e-1)) % n)
  for i in range(e):
    #Notice that the following element is an element of the subgroup generated by y. For some reason, the modulus operator misbehaves and gives incorrect float values unless specifically cast to int here.
    h.append((int((g*(-r[i]) + x)*(p**(e-1-i))) % n))
    #We apply the Baby Step Giant Step algorithm to p**e, y and h_i.
    d.append(babyStepGiantStep(n, p, y, h[i]))
    r.append(int((r[i] + d[i]*p**i) % n))

  return r[e]

def PohligHellman(n, factor_list, g, x):
  #We require factor_list has the form of list of pairs where the first entry is a prime factor of n  and the second entry is the multiplicity of each factor e.g. for n=12: [(2,2), (3,1)].
  #We also require that g is a generator for Z_n^+ and thus coprime to n.
  y = []
  f = [factor_list[i][0]**factor_list[i][1] for i in range(len(factor_list))]
  for k in range(len(factor_list)):
    #By Lagrange's Theorem the following element has order p_k**e_k where this is the corresponding prime factor of multiplicity e_k in the expansion of n.
    s = int(g*(n/f[k]) % n)
    h = int(x*(n/f[k]) % n)
    y.append(primePowerHellman(factor_list[k][0], factor_list[k][1], s, h))
             
  return chineseRemainderTheorem(y, f)
  
#Checking that the Baby Steps Giant Steps subalgorithm works. Here we require that for the prime number 8101 a number x such that 46x = 788. Notice that because 8101 is prime 46 is clearly a generator for the additive group Z_{8101}^+. The output is 1426, which is true because 46(1426) modulo 8101 is 788.
#print(babyStepGiantStep(8101, 8101, 46, 788))

#Here the correct answer should be 5, as the subgroup generated by 14 modulo 49 is [14], [28], [42], [7], [21], [35], [0].
#print(babyStepGiantStep(49, 7, 14, 21))

#For a final test, consider n= 360 = 3*3*2*2*2*5 and the subgroup generated by 68, which is [0, 68, 136, 204, 272, 340, 48, 116, 184, 252, 320, 28, 96, 164, 232, 300, 8, 76, 144, 212, 280, 348, 56, 124, 192, 260, 328, 36, 104, 172, 240, 308, 16, 84, 152, 220, 288, 356, 64, 132, 200, 268, 336, 44, 112, 180, 248, 316, 24, 92, 160, 228, 296, 4, 72, 140, 208, 276, 344, 52, 120, 188, 256, 324, 32, 100, 168, 236, 304, 12, 80, 148, 216, 284, 352, 60, 128, 196, 264, 332, 40, 108, 176, 244, 312, 20, 88, 156, 224, 292] of order 90 via the additiveSubgroup function.
#As required the following gets the answer 6 as clearly 6(68) modulo 360 is 48 via the prior calculations.
#print(babyStepGiantStep(360, 90, 68, 48))
#Do note however that the Baby Step Giant Step algorithm is inefficient for composite integers and Pohlig-Hellman is better for this. However, Pohlig-Hellman will not work with 68 because it does not generate Z_{360}^+.


#ans = primePowerHellman(5, 2, 17, 16)
#print("result should be 16, result: " + str(int(ans*17 % 25)))

#ans = primePowerHellman(2, 3, 5, 6)
#print("result should be 6, result: " + str(int(ans*5 % 8)))

#ans = primePowerHellman(11, 3, 32, 99)
#print("result should be 99, result: " + str(int(ans*32 % 1331)))

#ans = PohligHellman(36, [(2,2), (3,2)], 5, 21)
#print("result should be 21, result: " + str(int(ans*5) % 36))

#s = 352
#g = 121
#ans = PohligHellman(360, [(2,3), (3,2), (5,1)], g, s)
#print("result should be " + str(s) + ", result: " + str(int(ans*g) % 360))
